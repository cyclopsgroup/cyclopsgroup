[$link.absolute('jcli')|JCli]
&gt;

=Frequently asked questions

This page talks about several common use
cases that are not covered by [examples].

===How to define option or
argument that can take multiple values?

Add annotation
<code>@MultiValue</code>
to the setter method of option or arguments. Default collection passed
to setter method is ArrayList. For example:

##<![CDATA[
  @MultiValue
  @Option(name="o", longName="option", description="Example option")
 public void setOption(List<String> values) ...
##]]>

You may customize the implementation of collection, or the type of
element in collection, for example:

##<![CDATA[
  @MultiValue(listType=LinkedList.class, valueType=Integer.class)
  @Arguments
  void setIntegerArguments(List<Integer> values)...
##]]>

At this moment, multi values can't be passed as array yet.

===How to
define boolean option?

When option
type is boolean, JCli automatically
consider it as an option that
doesn't take value. In following case
option -f doesn't need value after
the option in command line

##<![CDATA[
  @Option(name="f", longName="flag", description="A flag option")
  void setFlag(boolean flag)...
##]]>

===How to customize conversion rule?

JCli internally use CAFF project for
value conversion. Customized conversion rules can be defined with
annotations, which can apply to the setter of option of argument. Take
@DateField annotation as an example, following code takes syntax such as
20100401 and call setDate with converted Date object.

##<![CDATA[
  @DateField(format="yyyyMMdd")
  @Option(name="d", longName="date", description="Option with customized conversion")
  void setDate(Date date) ...
##]]>

The conversion annotation can combine with
<code>@MultiValue</code>
annotation, which defines the conversion rules for element in
Collection. For example, following code defines a bean that takes list
of dates as arguments

##<![CDATA[
  @DateField(format="yyyyMMdd")
  @MultiValue(valueType=Date.class)
  @Arguments
  void setDates(List<Date> dates) ...
##]]>

